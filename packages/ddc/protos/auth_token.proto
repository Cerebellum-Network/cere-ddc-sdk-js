syntax = "proto3";

option go_package = "cere.network/ddc-storage-node/api/common";

import "common/signature.proto";

// Token represents trust chain of tokens where first token is verifiable by bucket access on chain and last token is generated by the client that sends a request
message AuthToken {
  common.Signature signature = 1; // signature signer is an issuer. issuer of first token should have an access on pallet level and subsequent tokens can skip 'issuer' and take 'subject' from previous token to verify signature
  Payload payload = 2;
}

message Payload {
  optional AuthToken prev = 1; // prev token in trust chain (based on known use cases max depth can be limited to 3 or increase to 5 to support more potential use cases)
  optional bytes subject = 2; // whom. every except last token should be non empty. next token should be signed by this subject
  optional bool canDelegate = 3; // subject can be prohibited to delegate access to anyone else (next token should be last)

  optional uint64 bucketId = 4 [jstype = JS_NORMAL]; // mentioned only once in trust chain (or even not mentioned at all if bucket owner decided to share access to all his buckets)
  repeated Operation operations = 5; // each next token in trust chain should have less or equal privileges (e.g. token restricted to 'get' operation can't have 'put' in next token)
  optional int64 expiresAt = 6; // each next token should expires earlier or at the same time as previous one (e.g. token can't have lower expiresAt than in next token)
  optional bytes pieceCid = 7; // mentioned only once in trust chain (in DAG API nested pieces can be accessed by path)
}

enum Operation {
  UNKNOWN = 0;
  PUT = 1;
  GET = 2;
  DELETE = 3;
}

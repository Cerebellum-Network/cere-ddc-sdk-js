syntax = "proto3";

package pb;

option go_package = "cere.network/ddc-storage-node/pb";

// Token represents trust chain of tokens where first token is verifiable by bucket access on chain and last token is generated by the client that sends a request
message Token {
  Header header = 1;
  Payload payload = 2;
  bytes signature = 3; // signature of protobuf serialised payload

  message Header {
    optional Algorithm algorithm = 1; // algorithm used to sign payload
    optional bytes issuer = 2; // who. issuer of first token should have an access on pallet level and subsequent tokens can skip 'issuer' and take 'subject' from previous token to verify signature

    enum Algorithm {
      ED_25519 = 0;
      SR_25519 = 1;
    }
  }

  message Payload {
    optional Token prev = 1; // prev token in trust chain (based on known use cases max depth can be limited to 3 or increase to 5 to support more potential use cases)
    optional bytes subject = 2; // whom. every except last token should be non empty. next token should be signed by this subject
    optional bool canDelegate = 3; // subject can be prohibited to delegate access to anyone else (next token should be last)

    optional uint64 bucketId = 4 [jstype = JS_NORMAL]; // mentioned only once in trust chain (or even not mentioned at all if bucket owner decided to share access to all his buckets)
    repeated Operation operations = 5; // each next token in trust chain should have less or equal privileges (e.g. token restricted to 'get' operation can't have 'put' in next token)
    optional int64 expiresAt = 6; // each next token should expires earlier or at the same time as previous one (e.g. token can't have lower expiresAt than in next token)
    optional bytes pieceCid = 7; // mentioned only once in trust chain (in DAG API nested pieces can be accessed by path)

    enum Operation {
      UNKNOWN = 0;
      PUT = 1;
      GET = 2;
      DELETE = 3;
    }
  }
}
